" ----- janus overrides -----

" set mapleader, so <Leader>-related stuff can be redefined
let mapleader = ','

" rewrite mapleader stuff
map <Leader><Leader> :ZoomWin<CR>
" Opens an edit command with the path of the currently edited file filled in
" not mapped to ,e since that's used by camelcasemotion
map <Leader>o :e <C-R>=expand("%:p:h") . "/" <CR>
" Opens a tab edit command with the path of the currently edited file filled in
map <Leader>te :tabe <C-R>=expand("%:p:h") . "/" <CR>

let NERDTreeIgnore=['\.pyc$', '\.rbc$', '\~$', '^tags$']

" livin' on the edge!
set noswapfile

" TagList settings
let Tlist_Use_Right_Window = 1
let Tlist_WinWidth = 70

" ----- my settings -----

" easy way to update/reload vim files
nmap <Leader>v :tabe ~/.vimrc.local<CR>
nmap <Leader>gv :tabe ~/.gvimrc.local<CR>
" http://vimcasts.org/episodes/updating-your-vimrc-file-on-the-fly/
autocmd! BufWritePost ~/.vimrc.local,~/.gvimrc.local source %
nmap <Leader>jr :tabe ~/.janus.rake<CR>

" expand tabs, always
set expandtab

" pressing enter while inside {} or [] doesn't always place the cursor
" on an indented next line, so map this to Ctrl-Enter
" <http://stackoverflow.com/questions/4768088/automatic-new-line-and-indentation-in-vim-when-inside-braces>
inoremap <C-Return> <CR><CR><C-o>k<Tab>

" convert strings to symbols
vmap <Leader>csy :s/\v["']([^"']+)["'] \=\> /:\1 => /g<CR>:nohls<CR>
" convert symbols to strings
vmap <Leader>cys :s/\v:([^:]+) \=\> /'\1' => /g<CR>:nohls<CR>

" Turn off some line specific stuff that is annoying
" Using autocmd here since formatoptions may be specified by the
" filetype - you can see what these options are with :h fo-table
set formatoptions=tqwvbc
autocmd! FileType * setl formatoptions=tqwvbc
" wrap lines at convenient points
set wrap linebreak showbreak=‣
" reasonable textwidth (imo)
set textwidth=80
"let g:old_textwidth=80
map <Leader>ww :call ToggleHardWrap()<CR>
" for wrapped lines, jump to the next row rather than the next line
nnoremap j gj
vnoremap j gj
nnoremap k gk
vnoremap k gk

function! ToggleHardWrap()
  if &textwidth
    let g:old_textwidth = &textwidth
    let &textwidth = 0
  else
    let &textwidth = g:old_textwidth
  endif
endfunction
" Wrap comment blocks
map gqc :call FormatComment()<CR>

" Cut a line without whitespace
" `"_d` puts the line into the "black-hole" register,
" see: <http://stackoverflow.com/questions/54255/in-vim-is-there-a-way-to-delete-without-putting-text-in-the-register>
nmap dl ^v$hd"_dd

" store lots of :cmdline history
set history=1000

" enable ctrl-n, ctrl-p in tab completion
set wildmenu

" override listchars
set listchars=tab:→→,trail:⋅,nbsp:⋅,eol:¬,extends:♒

" disable two-space joins
set nojoinspaces

" folding
set foldenable
" set foldcolumn=4 " show fold column
"set foldmethod=syntax " syntax / markers
"" NOTE!!!
"" Setting foldmethod to syntax will cause all sorts of problems.
"" See: <https://github.com/vim-ruby/vim-ruby/issues/8#issuecomment-327162>
"" And also: <http://vim.wikia.com/wiki/Keep_folds_closed_while_inserting_text>
set foldmethod=indent
set foldlevel=3 " start with no folding, but ready to go
set foldminlines=0 " Allow folding single lines
set foldnestmax=3 " Set max fold nesting level
"" Disable these for now as they're causing some dumb function to fail
"" when switching focus to a 'special' window (e.g. help window)
"au! BufReadPost * silent loadview
"au! BufWritePost * mkview

" show at least 3 lines above/below cursor
set scrolloff=3
" and at least 7 columns next to cursor
set sidescrolloff=7
set sidescroll=1

" some stuff to get the mouse going in term
" set mouse=a
" set ttymouse=xterm2

" hide buffers when not displayed (vs. unloading them)
set hidden

" the terminal has 256 color support
set t_Co=256

"map Q to something useful
noremap Q gq

"make Y consistent with C and D
nnoremap Y y$

" reverse Shift-[ and Shift-] to match j and k
"noremap { }
"noremap } {

" auto-change CWD when changing tree root
" let NERDTreeChDirMode=2
command! -n=? -complete=dir NT NERDTreeToggle <args>

" include space in comments
" let g:NERDSpaceDelims = 1
" let g:NERDRemoveExtraSpaces = 1

" put commandT window at the top of the screen
let g:CommandTMatchWindowAtTop=1

" disable hammer warning messages (bleh)
let g:HammerQuiet=1

" easy escape
imap jj <Esc>

if !has("gui")
  " set custom cursor -- vertical bar in insert mode (iTerm2)
  " from http://www.iterm2.com/#/section/documentation/escape_codes
  let &t_SI = "\<Esc>]50;CursorShape=1\x7"
  let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif

"make <c-l> clear the highlight as well as redraw
nnoremap <C-L> :nohls<CR><C-L>
inoremap <C-L> <C-O>:nohls<CR>

map <silent> <Leader>r :call Refresh()<CR>

function! Refresh()
  echo "refreshing tags and files..."

  silent !ctags -R

  if exists(":CommandTFlush") == 2
    CommandTFlush
  endif

  if exists("t:NERDTreeBufName")
    let nr = bufwinnr(t:NERDTreeBufName)
    if nr != -1
      exe nr . "wincmd w"
      exe substitute(mapcheck("R"), "<CR>", "", "")
      wincmd p
    endif
  endif

endfunction

colorscheme molokai

set colorcolumn=80,120

" from evilchelu:
" get the last pasted text
nnoremap gb '[V']

" current window always has a nice size
set winheight=10
" but the other windows aren't *too* small
" set winminheight=3

" new splits go below the current buffer
set splitbelow
" and to the right as well
set splitright

" strip leading tabs and trailing whitespace
command! Tr %s/\s\+$//ge | %s/\t/  /ge | nohlsearch
command! FixHashes %s/\(\S\)=>\(\S\)/\1 => \2/ge | %s/\t/  /ge | nohlsearch

" from http://stackoverflow.com/questions/676600/vim-replace-selected-text
vnoremap <C-r> "hy:%s/<C-r>h//gc<left><left><left>
vnoremap <C-a> "hy:Ack <C-r>h

map <leader>tn :tabnew<CR>
map <leader>ta :tabnew<CR>:Ack
map <leader>a :Ack
map <leader>x :x<CR>

" auto-save everything when vim loses focus
"autocmd! FocusLost * silent! wa

" http://vim.wikia.com/wiki/Disable_F1_built-in_help_key
" nmap <F1> :echo<CR>
" imap <F1> <C-o>:echo<CR>

" auto-reload any file modified outside vim
set autoread

" fix crontab editing
autocmd! BufEnter /private/tmp/crontab.* setl backupcopy=yes

" post gists privately by default
" let g:gist_private = 1
" show private gists by default
let g:gist_show_privates = 1

" Shortcuts for scrolling without moving the cursor
nnoremap <S-M-j> <C-e>
nnoremap <S-M-k> <C-y>

" Further emulate TextMate's invaluable auto-wrapping behavior
" <http://concisionandconcinnity.blogspot.com/2009/07/vim-part-ii-matching-pairs.html>
vnoremap <Leader>(  <ESC>`>a)<ESC>`<i(<ESC>
vnoremap <Leader>)  <ESC>`>a)<ESC>`<i(<ESC>
vnoremap <Leader>{  <ESC>`>a}<ESC>`<i{<ESC>
vnoremap <Leader>}  <ESC>`>a}<ESC>`<i{<ESC>
vnoremap <Leader>"  <ESC>`>a"<ESC>`<i"<ESC>
vnoremap <Leader>'  <ESC>`>a'<ESC>`<i'<ESC>
vnoremap <Leader>`  <ESC>`>a`<ESC>`<i`<ESC>
vnoremap <Leader>[  <ESC>`>a]<ESC>`<i[<ESC>
vnoremap <Leader>]  <ESC>`>a]<ESC>`<i[<ESC>

" ----- Session management -----

" customization for session plugin to hack
" local sessions stored in "session.vim" for individual projects
" with the assumption that projects are opened, give or take,
" with 'mvim .'
"
" autosave active sessions
let g:session_autosave = 1

map <leader>ss :call CreateLocalSession()<CR>
map <leader>sl :call LoadLocalSession()<CR>
map <leader>sd :DeleteSession<CR>

augroup LocalSession
  autocmd! VimEnter * call SetLocalSessionDirectory()
augroup END

function! SetLocalSessionDirectory()
  " opening up a specific directory, project-style
  if argc() == 1 && isdirectory(argv(0))
    let g:session_directory = fnamemodify(argv(0), ":p")
  else
    let g:session_directory = getcwd()
  end
endfunction

function! LoadLocalSession()
  let oldminheight = &winminheight
  set winminheight=1
  OpenSession session
  let &winminheight=oldminheight
endfunction

function! CreateLocalSession()
  let g:session_directory = getcwd()
  SaveSession session
endfunction

" ----- Whitespace removal -----
" Copied from <http://vim.wikia.com/wiki/Remove_unwanted_spaces>
function! TrimWhiteSpace()
  " do not record the whitespace removal in the undo history
  " <http://vim.1045645.n5.nabble.com/there-s-undojoin-how-about-dotjoin-td1203135.html>
  try
    undojoin
  catch
    " probably an undo was just issued, and so there's no way to
    " join the undo. which sucks.
  endtry
  %s/\s*$//
  ''
endfunction

"set list listchars=trail:.,extends:>
autocmd! FileWritePre * :call TrimWhiteSpace()
autocmd! FileAppendPre * :call TrimWhiteSpace()
autocmd! FilterWritePre * :call TrimWhiteSpace()
autocmd! BufWritePre * :call TrimWhiteSpace()

map <silent> <F2> :call TrimWhiteSpace()<CR>
map! <silent> <F2> :call TrimWhiteSpace()<CR>

" ----- tab movement setup -----
" tab mojo from ara.t.howard

" this lets 'tt' toggle between tabs
let g:tabno=tabpagenr()
autocmd! TabLeave * :let g:tabno = tabpagenr()
map tt :exec 'normal !'.g:tabno.'gt'<CR>

" map 'tn' to tabnext - a count is relative from current pos
" function! TabNext()
"     exec 'tabn'
" endfunction
" map tn :call TabNext()<CR>

" tab/cursor movement mappings
" note that this overwrites <C-L> for :nohlsearch

" map 'tg' to 'tab go' - this is an absolute tab number and quite useful with 'tt'
" map tg gt
" map <C-j> gt

" map 'tp' to 'tab previous'
" map tp gT
" map <C-k> gT

" ctrl-j and ctrl-k move tabs left(j)/right(k)
" map <C-h> :call TabMove(1)<CR>
" map <C-j> :call TabMove(1)<CR>
" map <C-k> :call TabMove(0)<CR>
" map <C-l> :call TabMove(0)<CR>
function! TabMove(n)
    let nr = tabpagenr()
    let size = tabpagenr('$')
    " do we want to go left?
    if (a:n != 0)
        let nr = nr - 2
    endif
    " crossed left border?
    if (nr < 0)
        let nr = size-1
        " crossed right border?
    elseif (nr == size)
        let nr = 0
    endif
    " fire move command
    exec 'tabm'.nr
endfunction

" map <C-J> <C-W>j<C-W>_
" map <C-K> <C-W>k<C-W>_
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-h> <C-w>h
map <C-l> <C-w>l
map <C-_> <C-w>_

map <C-Left> :call TabMove(1)<CR>
map <C-Right> :call TabMove(0)<CR>

" ----- syntax copying for presentations -----

" tell TOhtml to disable line numbering when generating HTML
let g:html_number_lines=0
" and to use a reasonable font
let g:html_font="Andale Mono"

" copy the entire buffer or selected text as RTF
" inspired by https://github.com/dharanasoft/rtf-highlight
" but only uses commands available by default on OS X.
"
" To set html conversion options, :help TOhtml
" And, undocumented, to set the font used,
" let g:html_font="Your Preferred Font"
"
function! CopyRTF(line1,line2)
  if !executable('textutil')
    echoerr "crap! textutil not found"
    return
  endif

  call tohtml#Convert2HTML(a:line1, a:line2)
  silent exe "%!textutil -convert rtf -stdin -stdout | pbcopy"
  silent bd!

  echomsg "RTF copied to clipboard"
endfunction

command! -range=% CopyRTF :call CopyRTF(<line1>,<line2>)

" ----- statusline from scrooloose/vimfiles -----

"statusline setup
set statusline=%f       "tail of the filename

"display a warning if fileformat isnt unix
set statusline+=%#warningmsg#
set statusline+=%{&ff!='unix'?'['.&ff.']':''}
set statusline+=%*

"display a warning if file encoding isnt utf-8
set statusline+=%#warningmsg#
set statusline+=%{(&fenc!='utf-8'&&&fenc!='')?'['.&fenc.']':''}
set statusline+=%*

set statusline+=%h      "help file flag
set statusline+=%y      "filetype
set statusline+=%r      "read only flag
set statusline+=%m      "modified flag

"display a warning if &et is wrong, or we have mixed-indenting
set statusline+=%#error#
set statusline+=%{StatuslineTabWarning()}
set statusline+=%*

set statusline+=%{StatuslineTrailingSpaceWarning()}

" set statusline+=%{StatuslineLongLineWarning()}

set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*

"display a warning if &paste is set
set statusline+=%#error#
set statusline+=%{&paste?'[paste]':''}
set statusline+=%*

" git status if applicable
set statusline+=%{fugitive#statusline()}

set statusline+=%=      "left/right separator
set statusline+=%{StatuslineCurrentHighlight()}\ \ "current highlight
set statusline+=%c,     "cursor column
set statusline+=%l/%L   "cursor line/total lines
set statusline+=\ %P    "percent through file
set laststatus=2

"recalculate the trailing whitespace warning when idle, and after saving
autocmd cursorhold,bufwritepost * unlet! b:statusline_trailing_space_warning

"return '[\s]' if trailing white space is detected
"return '' otherwise
function! StatuslineTrailingSpaceWarning()
    if !exists("b:statusline_trailing_space_warning")
        if search('\s\+$', 'nw') != 0
            let b:statusline_trailing_space_warning = '[\s]'
        else
            let b:statusline_trailing_space_warning = ''
        endif
    endif
    return b:statusline_trailing_space_warning
endfunction


"return the syntax highlight group under the cursor ''
function! StatuslineCurrentHighlight()
    let name = synIDattr(synID(line('.'),col('.'),1),'name')
    if name == ''
        return ''
    else
        return '[' . name . ']'
    endif
endfunction

"recalculate the tab warning flag when idle and after writing
autocmd cursorhold,bufwritepost * unlet! b:statusline_tab_warning

"return '[&et]' if &et is set wrong
"return '[mixed-indenting]' if spaces and tabs are used to indent
"return an empty string if everything is fine
function! StatuslineTabWarning()
    if !exists("b:statusline_tab_warning")
        let tabs = search('^\t', 'nw') != 0
        let spaces = search('^ ', 'nw') != 0

        if tabs && spaces
            let b:statusline_tab_warning =  '[mixed-indenting]'
        elseif (spaces && !&et) || (tabs && &et)
            let b:statusline_tab_warning = '[&et]'
        else
            let b:statusline_tab_warning = ''
        endif
    endif
    return b:statusline_tab_warning
endfunction

"recalculate the long line warning when idle and after saving
autocmd cursorhold,bufwritepost * unlet! b:statusline_long_line_warning

"return a warning for "long lines" where "long" is either &textwidth or 80 (if
"no &textwidth is set)
"
"return '' if no long lines
"return '[#x,my,$z] if long lines are found, were x is the number of long
"lines, y is the median length of the long lines and z is the length of the
"longest line
function! StatuslineLongLineWarning()
    if !exists("b:statusline_long_line_warning")
        let long_line_lens = s:LongLines()

        if len(long_line_lens) > 0
            let b:statusline_long_line_warning = "[" .
                        \ '#' . len(long_line_lens) . "," .
                        \ 'm' . s:Median(long_line_lens) . "," .
                        \ '$' . max(long_line_lens) . "]"
        else
            let b:statusline_long_line_warning = ""
        endif
    endif
    return b:statusline_long_line_warning
endfunction

"return a list containing the lengths of the long lines in this buffer
function! s:LongLines()
    let threshold = (&tw ? &tw : 80)
    let spaces = repeat(" ", &ts)

    let long_line_lens = []

    let i = 1
    while i <= line("$")
        let len = strlen(substitute(getline(i), '\t', spaces, 'g'))
        if len > threshold
            call add(long_line_lens, len)
        endif
        let i += 1
    endwhile

    return long_line_lens
endfunction

"find the median of the given array of numbers
function! s:Median(nums)
    let nums = sort(a:nums)
    let l = len(nums)

    if l % 2 == 1
        let i = (l-1) / 2
        return nums[i]
    else
        return (nums[l/2] + nums[(l/2)-1]) / 2
    endif
endfunction

"--------------------

"" Function to convert milliseconds to mm:ss.millis format
"fun! MSToHMS(ms)
"  let secf = str2float(a:ms) / 1000 " float
"  let min = float2nr(secf) / 60 " int
"  " let rem = sec - (60 * float2nr(sec / 60)) " mod can't div by float
"  let rem = string(fmod(secf, 60))
"  let pieces = split(rem, "\\.")
"  let sec = str2nr(pieces[0])
"  let dec = pieces[1]
"  return printf("%02d", min) . ':' . printf("%02d", sec) . "." . dec
"endfun
"
"" Function to convert mm:ss.millis format to milliseconds
"fun! HMSToMS(hms)
"  let m = matchlist(a:hms, '\v(\d+):(\d+)\.(\d+)')
"  let ms = (m[1] * 60 * 1000) + (m[2] * 1000) + m[3]
"  return ms
"endfun
