"=== Pre-configuration ===

" Be iMproved
set nocompatible

" Required for vundle
filetype off

" Load vundle
set rtp+=~/.vim/bundle/vundle/
call vundle#rc()

if filereadable(expand("~/.vimrc.bundles"))
  source ~/.vimrc.bundles
endif

syntax on
filetype plugin indent on


"=== Basic stuff ===

" Set mapleader, so that <Leader>-related stuff can be redefined
let mapleader = ','
let maplocalleader = ','

" Show line numbers
set number
" Show line and column number in status bar
set ruler
" When I enter text, use UTF-8
set encoding=utf-8
" Livin' on the edge!
set noswapfile
" Store lots of :cmdline history
set history=1000
" Hide buffers when not displayed (vs. unloading them)
set hidden
" Disable the splash screen
set shortmess+=I
" Remove delay after pressing Escape and clearing the visual selection
set timeoutlen=1000 ttimeoutlen=0

" Fix so typing '#' does not jump to start of line
" http://stackoverflow.com/questions/2063175/vim-insert-mode-comments-go-to-start-of-line
set nosmartindent
au! FileType slim setl nosmartindent

" Per-directory .vimrc files
set exrc            " enable per-directory .vimrc files
set secure          " disable unsafe commands in local .vimrc files

"=== Magic ===

" Auto-save everything when vim loses focus
" http://vim.wikia.com/wiki/Auto_save_files_when_focus_is_lost
autocmd! FocusLost * silent! wa

" Auto-reload any file modified outside vim

" Source: <http://vim.wikia.com/wiki/Have_Vim_check_automatically_if_the_file_has_changed_externally>

" If you are using a console version of Vim, or dealing
" with a file that changes externally (e.g. a web server log)
" then Vim does not always check to see if the file has been changed.
" The GUI version of Vim will check more often (for example on Focus change),
" and prompt you if you want to reload the file.
"
" There can be cases where you can be working away, and Vim does not
" realize the file has changed. This command will force Vim to check
" more often.
"
" Calling this command sets up autocommands that check to see if the
" current buffer has been modified outside of vim (using checktime)
" and, if it has, reload it for you.
"
" This check is done whenever any of the following events are triggered:
" * BufEnter
" * CursorMoved
" * CursorMovedI
" * CursorHold
" * CursorHoldI
"
" In other words, this check occurs whenever you enter a buffer, move the cursor,
" or just wait without doing anything for 'updatetime' milliseconds.
"
" Normally it will ask you if you want to load the file, even if you haven't made
" any changes in vim. This can get annoying, however, if you frequently need to reload
" the file, so if you would rather have it to reload the buffer *without*
" prompting you, add a bang (!) after the command (WatchForChanges!).
" This will set the autoread option for that buffer in addition to setting up the
" autocommands.
"
" If you want to turn *off* watching for the buffer, just call the command again while
" in the same buffer. Each time you call the command it will toggle between on and off.
"
" WatchForChanges sets autocommands that are triggered while in *any* buffer.
" If you want vim to only check for changes to that buffer while editing the buffer
" that is being watched, use WatchForChangesWhileInThisBuffer instead.
"
command! -bang WatchForChanges                  :call WatchForChanges(@%,  {'toggle': 1, 'autoread': <bang>0})
command! -bang WatchForChangesWhileInThisBuffer :call WatchForChanges(@%,  {'toggle': 1, 'autoread': <bang>0, 'while_in_this_buffer_only': 1})
command! -bang WatchForChangesAllFile           :call WatchForChanges('*', {'toggle': 1, 'autoread': <bang>0})

" WatchForChanges function
"
" This is used by the WatchForChanges* commands, but it can also be
" useful to call this from scripts. For example, if your script executes a
" long-running process, you can have your script run that long-running process
" in the background so that you can continue editing other files, redirects its
" output to a file, and open the file in another buffer that keeps reloading itself
" as more output from the long-running command becomes available.
"
" Arguments:
" * bufname: The name of the buffer/file to watch for changes.
"     Use '*' to watch all files.
" * options (optional): A Dict object with any of the following keys:
"   * autoread: If set to 1, causes autoread option to be turned on for the buffer in
"     addition to setting up the autocommands.
"   * toggle: If set to 1, causes this behavior to toggle between on and off.
"     Mostly useful for mappings and commands. In scripts, you probably want to
"     explicitly enable or disable it.
"   * disable: If set to 1, turns off this behavior (removes the autocommand group).
"   * while_in_this_buffer_only: If set to 0 (default), the events will be triggered no matter which
"     buffer you are editing. (Only the specified buffer will be checked for changes,
"     though, still.) If set to 1, the events will only be triggered while
"     editing the specified buffer.
"   * more_events: If set to 1 (the default), creates autocommands for the events
"     listed above. Set to 0 to not create autocommands for CursorMoved, CursorMovedI,
"     (Presumably, having too much going on for those events could slow things down,
"     since they are triggered so frequently...)
"
function! WatchForChanges(bufname, ...)
  " Figure out which options are in effect
  if a:bufname == '*'
    let id = 'WatchForChanges'.'AnyBuffer'
    " If you try to do checktime *, you'll get E93: More than one match for * is given
    let bufspec = ''
  else
    if bufnr(a:bufname) == -1
      echoerr "Buffer " . a:bufname . " doesn't exist"
      return
    end
    let id = 'WatchForChanges'.bufnr(a:bufname)
    let bufspec = a:bufname
  end

  if len(a:000) == 0
    let options = {}
  else
    if type(a:1) == type({})
      let options = a:1
    else
      echoerr "Argument must be a Dict"
    end
  end
  let autoread    = has_key(options, 'autoread')    ? options['autoread']    : 0
  let toggle      = has_key(options, 'toggle')      ? options['toggle']      : 0
  let disable     = has_key(options, 'disable')     ? options['disable']     : 0
  let more_events = has_key(options, 'more_events') ? options['more_events'] : 1
  let while_in_this_buffer_only = has_key(options, 'while_in_this_buffer_only') ? options['while_in_this_buffer_only'] : 0

  if while_in_this_buffer_only
    let event_bufspec = a:bufname
  else
    let event_bufspec = '*'
  end

  let reg_saved = @"
  "let autoread_saved = &autoread
  let msg = "\n"

  " Check to see if the autocommand already exists
  redir @"
    silent! exec 'au '.id
  redir END
  let l:defined = (@" !~ 'E216: No such group or event:')

  " If not yet defined...
  if !l:defined
    if l:autoread
      let msg = msg . 'Autoread enabled - '
      if a:bufname == '*'
        set autoread
      else
        setlocal autoread
      end
    end
    silent! exec 'augroup '.id
      if a:bufname != '*'
        "exec "au BufDelete    ".a:bufname . " :silent! au! ".id . " | silent! augroup! ".id
        "exec "au BufDelete    ".a:bufname . " :echomsg 'Removing autocommands for ".id."' | au! ".id . " | augroup! ".id
        exec "au BufDelete    ".a:bufname . " execute 'au! ".id."' | execute 'augroup! ".id."'"
      end
        exec "au BufEnter     ".event_bufspec . " :checktime ".bufspec
        exec "au CursorHold   ".event_bufspec . " :checktime ".bufspec
        exec "au CursorHoldI  ".event_bufspec . " :checktime ".bufspec

      " The following events might slow things down so we provide a way to disable them...
      " vim docs warn:
      "   Careful: Don't do anything that the user does
      "   not expect or that is slow.
      if more_events
        exec "au CursorMoved  ".event_bufspec . " :checktime ".bufspec
        exec "au CursorMovedI ".event_bufspec . " :checktime ".bufspec
      end
    augroup END
    let msg = msg . 'Now watching ' . bufspec . ' for external updates...'
  end

  " If they want to disable it, or it is defined and they want to toggle it,
  if l:disable || (l:toggle && l:defined)
    if l:autoread
      let msg = msg . 'Autoread disabled - '
      if a:bufname == '*'
        set noautoread
      else
        setlocal noautoread
      end
    end
    " Using an autogroup allows us to remove it easily with the following
    " command. If we do not use an autogroup, we cannot remove this
    " single :checktime command
    " augroup! checkforupdates
    silent! exec 'au! '.id
    silent! exec 'augroup! '.id
    let msg = msg . 'No longer watching ' . bufspec . ' for external updates.'
  elseif l:defined
    let msg = msg . 'Already watching ' . bufspec . ' for external updates'
  end

  "echo msg
  let @"=reg_saved
endfunction

" Always watch for changes
let autoreadargs={'autoread':1}
execute WatchForChanges("*",autoreadargs)

"=== Whitespace removal on save ===

" Copied from <http://vim.wikia.com/wiki/Remove_unwanted_spaces>
function! TrimWhiteSpace()
  " do not record the whitespace removal in the undo history
  " <http://vim.1045645.n5.nabble.com/there-s-undojoin-how-about-dotjoin-td1203135.html>
  try
    undojoin
  catch
    " probably an undo was just issued, and so there's no way to
    " join the undo. which sucks.
  endtry
  %s/\s*$//
  ''
endfunction

autocmd! FileWritePre * :call TrimWhiteSpace()
autocmd! FileAppendPre * :call TrimWhiteSpace()
autocmd! FilterWritePre * :call TrimWhiteSpace()
autocmd! BufWritePre * :call TrimWhiteSpace()

"=== Colors ===

" The terminal has 256 color support
set t_Co=256

" Color scheme type
let s:color_scheme_type="dark"

" Set color scheme
if s:color_scheme_type == "dark"
  silent! colorscheme molokai
else
  set background=light
  silent! colorscheme earendel
endif

" Set color column
set colorcolumn=80,100,120
if s:color_scheme_type == "dark"
  hi ColorColumn guibg=#17191A ctermbg=234
else
  hi ColorColumn guibg=#c0c0c0 ctermbg=234
endif

set cursorline

"=== Whitespace ===

set tabstop=2 shiftwidth=2
autocmd! FileType {ruby,css,javascript,coffee,html,xml,markdown,js,haml,sh,eruby,scss,vim} set softtabstop=2 expandtab

set list listchars=tab:⊢—,trail:⋅,nbsp:⋅,eol:¬,extends:⨠

" Disable two-space joins
set nojoinspaces

set wrap linebreak showbreak=‣

" override textwidth when file is opened, Ruby files are somehow set to 72
autocmd! BufRead,BufNewFile * setlocal textwidth=80
" git commits are the only file type where 72 is okay
autocmd! BufRead,BufNewFile gitcommit setlocal textwidth=72

" In Clojure, words that contains dots are usually namespaces
" Source: <http://stackoverflow.com/questions/225266/customising-word-separators-in-vi>
autocmd! FileType clojure set iskeyword-=.

" For wrapped lines, jump to the next row rather than the next line
nnoremap j gj
vnoremap j gj
nnoremap k gk
vnoremap k gk

" Toggle hard wrap
function! ToggleHardWrap()
  if &textwidth
    let g:old_textwidth = &textwidth
    let &textwidth = 0
  else
    let &textwidth = g:old_textwidth
  endif
endfunction
noremap <Leader>ww :call ToggleHardWrap()<CR>

" Make it easy to toggle wrapping
map <Leader>wi :set invwrap<CR>

"=== Searching ===

set hlsearch
set incsearch

"=== Tab completion ===

set wildmode=list:longest,list:full
set wildignore+=*.o,*.obj,.git,*.rbc,*.class,.svn,bundle/**,vendor/gems/*,vendor/ruby/**,tmp/cache

" When editing a file, always jump to the last known cursor position.
" Don't do it for commit messages, when the position is invalid, or when
" inside an event handler (happens when dropping a file on gvim).
autocmd BufReadPost *
  \ if &ft != 'gitcommit' && line("'\"") > 0 && line("'\"") <= line("$") |
  \   exe "normal g`\"" |
  \ endif

"=== File type specific settings ===

" make uses real tabs
autocmd! FileType make setl noexpandtab

" Many Ruby files aren't named that way
autocmd! BufRead,BufNewFile {config.ru,Gemfile,Guardfile,Rakefile,Thorfile,Vagrantfile,Appraisals} set ft=ruby

" Turn on autoindentation since vim-markdown does not include this
autocmd! BufRead,BufNewFile *.{md,mkd,mkdn,mark*} setl ft=markdown autoindent

" Add JSON syntax highlighting
autocmd! BufNewFile,BufRead *.json set ft=javascript

" Make Python follow PEP8 ( http://www.python.org/dev/peps/pep-0008/ )
autocmd! FileType python set softtabstop=4 tabstop=4 shiftwidth=4 textwidth=79

" Fix crontab editing
autocmd! BufEnter /private/tmp/crontab.* setl backupcopy=yes

" Use modeline overrides
set modeline
set modelines=10

" Allow backspacing over everything in insert mode
set backspace=indent,eol,start

" Paste mode
set pastetoggle=<F3>

" Turn off some line specific stuff that is annoying
" Using autocmd here since formatoptions may be specified by the
" filetype - you can see what these options are with :h fo-table
set formatoptions=tcroqvb
autocmd! FileType * setl formatoptions=tcroqvb

" Enable Ctrl-N, Ctrl-P in tab completion
set wildmenu

"=== Folding ===

set foldenable

"" NOTE!!!
"" Setting foldmethod to syntax will cause all sorts of problems.
"" See: <https://github.com/vim-ruby/vim-ruby/issues/8#issuecomment-327162>
"" And also: <http://vim.wikia.com/wiki/Keep_folds_closed_while_inserting_text>
set foldmethod=indent
set foldlevel=6    " start with no folding, but ready to go
set foldminlines=0 " Allow folding single lines
set foldnestmax=6  " Set max fold nesting level
"set foldcolumn=4 " Show fold column

"=== Window/cursor display ===

" Show at least 3 lines above/below cursor
set scrolloff=3
" and at least 7 columns next to cursor
set sidescrolloff=7
set sidescroll=1

" Set custom cursor -- vertical bar in insert mode (iTerm2)
" From http://www.iterm2.com/#/section/documentation/escape_codes
" Also https://gist.github.com/andyfowler/1195581 for the tmux stuff
if exists('$TMUX')
  let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
  let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
else
  let &t_SI = "\<Esc>]50;CursorShape=1\x7"
  let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif

" Current window always has a nice size
set winheight=10

" New splits go below the current buffer
set splitbelow
" and to the right as well
set splitright

"=== Various mappings ===

" % to bounce from do to end etc.
runtime! macros/matchit.vim

" Easy way to update/reload vim files
nmap <Leader>ev :tabe ~/.vimrc<CR>
nmap <Leader>eg :tabe ~/.gvimrc<CR>
" http://vimcasts.org/episodes/updating-your-vimrc-file-on-the-fly/
autocmd! BufWritePost ~/.vimrc,~/.gvimrc source %

" Window movement
noremap <C-j> <C-w>j
noremap <C-k> <C-w>k
noremap <C-h> <C-w>h
noremap <C-l> <C-w>l
noremap <C-_> <C-w>_

" Tab movement
noremap <C-e> gT
noremap <C-t> gt

" pressing < and > in visual mode keeps the selection
vnoremap < <gv
vnoremap > >gv

" Map Q to something useful
noremap Q gq

" Make Y consistent with C and D
nnoremap Y y$

" Easier way to save
nnoremap <C-s> :w<CR>
inoremap <C-s> :w<CR>i
" Easy way to save and close the current buffer
nnoremap <C-q> :wq<CR>
inoremap <C-q> <Esc>:wq<CR>

" I hit this way too often, let's just no-op it
noremap K <Esc>

" Make <C-\> clear the highlight as well as redraw
nnoremap <C-\> :nohls<CR>
inoremap <C-\> <C-O>:nohls<CR>

" Cut a line without whitespace
" `"_d` puts the line into the "black-hole" register,
" See: <http://stackoverflow.com/questions/54255/in-vim-is-there-a-way-to-delete-without-putting-text-in-the-register>
nmap <Leader>dl ^v$hd"_dd
" Paste a string into the next line keeping the same indentation level
nmap <Leader>p> o<Space><Backspace><Esc>p
" Paste a string into the previous line keeping the same indentation level
nmap <Leader>P> O<Space><Backspace><Esc>p
" Open a new line at the end of the following line
nmap <Leader>oi j$a
" Paste overwriting the current selection, without first storing the text to be
" replaced in the current register
vmap <Leader>pp "_dP
" Paste overwriting the current line
nmap <Leader>pc "_ddP
nmap <Leader>pd "_ddP
" Paste overwriting everything to the end of the line ($)
nmap <Leader>pr "_Dp
nmap <Leader>p$ "_Dp
" Paste into the next line replacing it
nmap <Leader>po j"_ddP
" Paste into the previous line replacing it
nmap <Leader>Po k"_ddP

" Convert strings to symbols
vmap <Leader>csy :s/\v["']([^"']+)["'] \=\> /:\1 => /g<CR>:nohls<CR>
" Convert symbols to strings
vmap <Leader>cys :s/\v:([^:]+) \=\>/'\1' =>/g<CR>:nohls<CR>

" Search and replace word under cursor
" http://vim.wikia.com/wiki/Search_and_replace_the_word_under_the_cursor
nnoremap <Leader>se :%s/\<<C-r><C-w>\>/

" Join comments so we can easily apply gqc
vmap <Leader>jc :s/\v[\n ]+#[ ]+/ /g<CR>:nohls<CR>i<Space>#<Space><Esc>
" A form of gqc that joins the selected comment lines first
vmap <Leader>gqc <Leader>jc<S-V>gqc
" Format paragraphs too
nmap <Leader>gqp vipQ$

" Identify syntax group at cursor
" http://vim.wikia.com/wiki/Identify_the_syntax_highlighting_group_used_at_the_cursor
map <Leader>syn :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
\ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
\ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

"=== Plugin configuration ===

"--- NERDTree ---

let NERDTreeIgnore=['\.pyc$', '\.rbc$', '\~$', '^tags$']
nnoremap <silent> <Leader>tt :NERDTreeToggle<CR>
" Open the nerd tree window first, in CWD, so the find doesn't change
" the tree root.
nnoremap <silent> <Leader>tf :NERDTree<CR><C-w>p:NERDTreeFind<CR>
" Auto-change cwd when changing tree root
let NERDTreeChDirMode=2
" Close vim if the only window left open is a NERDTree
autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif

"--- Ctrl-P ---

let g:ctrlp_match_window_bottom = 0
let g:ctrlp_match_window_reversed = 0
let g:ctrlp_max_height = 20
set runtimepath^=~/.vim/bundle/ctrlp

" Command to refresh both Command-T and NERDTree
" (but mainly Command-T)
function! Refresh()
  echo "Refreshing files..."

  if exists(":CtrlPClearCache") == 2
    CtrlPClearCache
  endif

  if exists("t:NERDTreeBufName")
    let nr = bufwinnr(t:NERDTreeBufName)
    if nr != -1
      exe nr . "wincmd w"
      exe substitute(mapcheck("R"), "<CR>", "", "")
      wincmd p
  endif
endif
endfunction
noremap <silent> <Leader>rr :call Refresh()<CR>

"--- NERDCommenter ---

" NERDCommenter already provides mappings. The best one to use is probably
" <Leader>cl and <Leader>cu.

"--- FormatComment

noremap <Leader>qc :call FormatComment()<CR>

"--- Clojure ---

" Settings for the VimClojure plugin
" https://github.com/daveray/vimclojure-easy/blob/master/vimrc.vim
let vimclojure#FuzzyIndent=1
let vimclojure#HighlightBuiltins=1
let vimclojure#HighlightContrib=1
let vimclojure#DynamicHighlighting=1
let vimclojure#ParenRainbow=0
let vimclojure#WantNailgun=1
let vimclojure#NailgunClient = $HOME . "/.bin/ng"

au! FileType clojure

au FileType clojure call vimclojure#MakeCommandPlug("n", "RunTestsReloadAll", "vimclojure#RunTests", "1")
au FileType clojure call vimclojure#MapPlug("n", "rT", "RunTestsReloadAll")

"--- vim-indent-guides ---

let g:indent_guides_enable_on_vim_startup=1
let g:indent_guides_auto_colors=0
autocmd! VimEnter,Colorscheme * :hi IndentGuidesEven guibg=#262325 ctermbg=234
" autocmd! VimEnter,Colorscheme * :hi IndentGuidesEven guibg=#e5e5e5

"--- coffee-script ---

hi link coffeeObject NONE
hi link coffeeBracket NONE
hi link coffeeCurly NONE
hi link coffeeParen NONE
hi link coffeeSpecialOp NONE

" coffee-script highlights operators and stuff, it's really annoying
hi clear Operator
hi clear SpecialOp

"--- powerline ---

let g:Powerline_symbols = 'fancy'
set laststatus=2   " otherwise the powerline only appears for split windows
silent! PowerlineReloadColorscheme

"--- ShowMarks ---

hi default ShowMarksHLl cterm=bold ctermfg=darkblue ctermbg=233 "gui=bold guifg=blue guibg=lightblue
hi default ShowMarksHLu cterm=bold ctermfg=darkblue ctermbg=233 "gui=bold guifg=blue guibg=lightblue
hi default ShowMarksHLo cterm=bold ctermfg=darkblue ctermbg=233 "gui=bold guifg=blue guibg=lightblue
hi default ShowMarksHLm cterm=bold ctermfg=darkblue ctermbg=233 "gui=bold guifg=blue guibg=lightblue

"--- vroom

let g:vroom_map_keys = 0
let g:vroom_spec_command = 'zeus rspec '
let g:vroom_use_bundle_exec = 0
let g:vroom_clear_screen = 0
let g:vroom_use_vimux = 1
nnoremap <Leader>ta :VroomRunTestFile<CR>
nnoremap <Leader>tn :VroomRunNearestTest<CR>

