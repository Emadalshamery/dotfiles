#!/bin/bash

# Adapted from: <https://gist.github.com/capocasa/134ce5312747e585a3e05cf70feebf7b>

set -euo pipefail

source "$HOME/.config/core-helpers.sh"

## Constants

EXECUTABLE="$(basename "$0")"

## Configuration

set-debug-mode "false"
set-color-mode "true"

BOUNCE_EXIT_CODE=-700
LOCKFILE_DIRECTORY=/tmp

## Parameters

duration_option=
command=()

## Actions

print-usage() {
  cat <<EOT
USAGE: $EXECUTABLE [OPTIONS] -- [COMMAND]

\`$EXECUTABLE\` is used to prevent a command from being run too many times
within a certain time period. To do this, it creates a lockfile holding the
current time extended by a designated duration, then sleeps until the time
therein is met. If another instance of \`$EXECUTABLE\` is run, and the lockfile
exists, that instance will exit with a code of -700, and the timer from the
first instance will be reset (by updating the lockfile). This process will
continue until no other instance of \`$EXECUTABLE\` is run, after which the
given command will be run. This is process is called "debouncing".

OPTIONS:

-d, --duration=SECONDS
    The amount of time to wait, in seconds.

-h, --help
    You're looking at it!
EOT
}

parse-args() {
  local process_rest_of_args=0

  while [[ $# -gt 0 ]]; do
    if [[ $process_rest_of_args -eq 1 ]]; then
      command+=("${1:-}")
      shift
    else
      case "${1:-}" in
        --duration | -d)
          duration_option=$2
          shift 2
          ;;
        --help | -h)
          print-usage
          exit 0
          ;;
        --)
          if [[ ${#command[@]} -gt 0 ]]; then
            echo "ERROR: It seems you've started to provide a command to run after providing options."
            echo "ERROR: Please specify the command after --."
            echo
            print-usage
            exit 1
          fi
          process_rest_of_args=1
          shift
          ;;
        *)
          command+=("${1:-}")
          shift
          ;;
      esac
    fi
  done
}

validate-args() {
  if [[ ${#command[@]} -eq 0 ]]; then
    echo "ERROR: No command to run!"
    exit 1
  fi
}

main() {
  local command_hash
  local lockfile
  local current_time
  local read_time
  local read_duration
  local time_to_run

  parse-args "$@"
  validate-args

  command_hash=$(echo -n "%s" "${command[@]}" | /opt/homebrew/bin/md5sum | head -c 32)
  lockfile="$LOCKFILE_DIRECTORY/debounce-$command_hash"
  current_time=$(date +%s)
  debug "Current time: $current_time"

  if [[ -f "$lockfile" ]]; then
    IFS=$'\t' read -r read_time read_duration < "$lockfile"
    time_to_run="$((read_time+read_duration))"
    debug "Read time: $read_time"
    debug "Read duration: $read_duration"
    debug "Time to run: $time_to_run"
    if [[ $current_time -lt $time_to_run ]]; then
      debug "Another instance of this command is being run. Advancing timer by $read_duration."
      echo -e "${current_time}\t${read_duration}" > "$lockfile"
      exit $BOUNCE_EXIT_CODE
    else
      debug "Another instance of this command is being run, but timer has expired. Removing lockfile and continuing."
      rm -f "$lockfile"
    fi
  fi

  if [[ -z $duration_option ]]; then
    echo "ERROR: --duration missing."
    echo
    print-usage
    exit 1
  fi

  echo -e "${current_time}\t${duration_option}" > "$lockfile"
  while true; do
    current_time=$(date +%s)
    IFS=$'\t' read -r read_time read_duration < "$lockfile"
    time_to_run="$((read_time+read_duration))"
    debug "Current time: $current_time"
    debug "Read time: $read_time"
    debug "Read duration: $read_duration"
    debug "Time to run: $time_to_run"
    if [[ $current_time -lt $time_to_run ]]; then
      debug "It's not time to run this command yet, waiting a half a second..."
      sleep 0.5
    else
      debug "Time to run the command!"
      break
    fi
  done
  rm -f "$lockfile"
  exec "${command[@]}"
}

main "$@"
